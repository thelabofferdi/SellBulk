use anyhow::Result;
use serde::{Deserialize, Serialize};

/// AI generation constraints
#[derive(Debug, Clone)]
pub struct AIConstraints {
    pub max_length: usize,
    pub tone: String,
    pub objective: String,
    pub prohibitions: Vec<String>,
}

/// IA Gateway - Generates text ONLY, under strict constraints
/// AI CANNOT: decide, ask free questions, propose human contact, 
/// invent information, send media
pub struct IAGateway {
    api_key: Option<String>,
    client: reqwest::Client,
}

#[derive(Debug, Serialize)]
struct AIRequest {
    prompt: String,
    max_tokens: usize,
    temperature: f32,
}

#[derive(Debug, Deserialize)]
struct AIResponse {
    text: String,
}

impl IAGateway {
    pub fn new(api_key: Option<String>) -> Self {
        Self {
            api_key,
            client: reqwest::Client::new(),
        }
    }

    /// Generate text under constraints
    /// Prompts are ALWAYS generated by backend, never by AI
    pub async fn generate_text(&self, constraints: AIConstraints) -> Result<String> {
        // Build deterministic prompt
        let prompt = format!(
            "Objectif: {}\nTone: {}\nLongueur max: {} caractères\nInterdictions: {}\n\nGénère une réponse:",
            constraints.objective,
            constraints.tone,
            constraints.max_length,
            constraints.prohibitions.join(", ")
        );

        // TODO: Call actual AI API (OpenAI, Anthropic, etc.)
        log::info!("AI prompt: {}", prompt);

        // Placeholder response
        Ok("Réponse générée par IA (TODO: implémenter appel API)".to_string())
    }

    /// Check if AI is available
    pub fn is_available(&self) -> bool {
        self.api_key.is_some()
    }
}

impl Default for IAGateway {
    fn default() -> Self {
        Self::new(None)
    }
}
